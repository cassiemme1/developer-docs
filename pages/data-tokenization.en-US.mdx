import { Callout } from 'nextra-theme-docs';

# Data Tokenization

Developers can arbitrarily customize the data monetization layer business based on the [DataAssetBase](https://github.com/pyra-marketplace/assets-sdk/blob/main/src/data-asset/DataAssetBase.ts) base class.

## DataAssetBase

This is the basic type of DataAssetBase:

```javascript
import { Attached, DataAsset, Connector, EncryptionProvider, MonetizationProvider } from "@meteor-web3/connector";
import { BigNumberish, BytesLike, Signer } from "ethers";
import { ChainId } from "../types";
import { GeneralAccessConditions, SourceAssetConditionInput, SourceAssetConditions, LinkedAssetConditions, LinkedAssetConditionInput, ActParams, PublishParams, AddActionsParams } from "./types";
export declare class DataAssetBase {
    fileOrFolderId?: string;
    assetContract?: string;
    chainId?: ChainId;
    assetId?: string;
    generalAccessConditions?: GeneralAccessConditions;
    sourceAssetConditions?: SourceAssetConditions;
    linkedAssetConditions?: LinkedAssetConditions;
    monetizationProvider?: MonetizationProvider;
    encryptionProvider?: EncryptionProvider;
    connector: Connector;
    signer?: Signer;
    constructor({ chainId, connector, fileOrFolderId, assetContract, assetId }: {
        chainId?: ChainId;
        connector: Connector;
        fileOrFolderId?: string;
        assetContract?: string;
        assetId?: string;
    });
    protected createAssetHandler(publishParams: PublishParams, withSig?: boolean): Promise<string>;
    protected _act(actParams: ActParams, withSig?: boolean): Promise<BytesLike[]>;
    protected _addActions(addActionsParams: AddActionsParams, withSig?: boolean): Promise<void>;
    protected _checkERC20BalanceAndAllowance(currency: string, amount: BigNumberish, spender: string): Promise<void>;
    private _buildPublishSignature;
    private _buildActSignature;
    private _buildAddActionsSignature;
    protected addGeneralCondition(acl: GeneralAccessConditions): void;
    protected addSourceCondition({ acl, timestamp }: {
        acl: Omit<SourceAssetConditionInput, "functionParams">;
        timestamp?: number;
    }): void;
    protected addLinkCondition({ acl, linkedAsset, attached }: {
        acl: Omit<LinkedAssetConditionInput, "contractAddress" | "functionParams" | "chain">;
        linkedAsset?: DataAsset;
        attached?: Attached;
    }): Promise<void>;
    protected applyFileConditions(fileId?: string): Promise<{
        fileContent: {
            file: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external">;
            content?: import("@meteor-web3/connector").FileContent | undefined;
        };
    }>;
    protected applyFolderConditions(folderId?: string): Promise<import("@meteor-web3/connector").StructuredFolder>;
    getAssetOwner(assetId: BytesLike): Promise<string>;
}
```

### createAssetHandler

Create an asset with data as the parameters required by the base class contract itself. The action array can be passed to the action contract deployed by the developer, and the actionInitData can be passed to the contract specific method parameters or an empty array. After successful execution, store the assetId in the class.

### addGeneralCondition

Add basic access control conditions, such as wallet address, balance, and whether NFTs are held, generally without involving custom contract conditions. Will add an object to the generalAccessionConditions array.

### addSourceCondition

Adding access control conditions for custom contracts. Requires meeting certain conditions of the asset itself. Will add an object to the sourceAssetConditions array.

### addLinkCondition

Adding access control conditions for custom contracts. Requires meeting certain conditions that are not specific to the asset itself, but rather those of other assets. Will add an object to the linkedAssetConditions array.

### applyFileConditions

Similar to createTokenFile, but only for the existing private file instead of creating a new one.

### applyFolderConditions

In order to successfully unlock, you need to call a contract function to meet the access control conditions.

## Demonstration

[DataToken](https://github.com/pyra-marketplace/assets-sdk/blob/main/src/data-token/DataToken.ts) is a demonstration sdk based on DataAssetBase base class.

This is the basic type of DataToken:

```javascript
import { BigNumber, BigNumberish } from "ethers";
import { Connector, FileContent } from "@meteor-web3/connector";
import { DataAssetBase } from "../data-asset/DataAssetBase";
import { ChainId } from "../types";
export declare class DataToken extends DataAssetBase {
    constructor({ chainId, connector, fileId, assetId }: {
        chainId?: ChainId;
        connector: Connector;
        fileId?: string;
        assetId?: string;
    });
    publish({ resourceId, actionsConfig, withSig }: {
        resourceId: string;
        actionsConfig?: {
            collectAction?: {
                currency: string;
                amount: BigNumberish;
                totalSupply?: BigNumberish;
            };
        };
        withSig?: boolean;
    }): Promise<string>;
    applyConditionsToFile(timestamp?: number): Promise<{
        fileContent: {
            file: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external">;
            content?: FileContent | undefined;
        };
    }>;
    createTokenFile({ modelId, fileName, fileContent, actionsConfig, timestamp, withSig }: {
        modelId: string;
        fileName?: string;
        fileContent: FileContent;
        actionsConfig: {
            collectAction?: {
                currency: string;
                amount: BigNumberish;
                totalSupply?: BigNumberish;
            };
        };
        timestamp?: number;
        withSig?: boolean;
    }): Promise<{
        fileContent: {
            file: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external">;
            content?: FileContent | undefined;
        };
    }>;
    monetizeFile({ actionsConfig, withSig }: {
        actionsConfig: {
            collectAction?: {
                currency: string;
                amount: BigNumberish;
                totalSupply?: BigNumberish;
            };
        };
        withSig?: boolean;
    }): Promise<{
        fileContent: {
            file: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external">;
            content?: FileContent | undefined;
        };
    }>;
    getTokenAsset(): Promise<import("./abi/typechain/DataToken").IDataToken.TokenAssetStruct>;
    isCollected(account: string): Promise<boolean>;
    addActions({ collectAction, withSig }: {
        collectAction?: {
            currency: string;
            amount: BigNumberish;
            totalSupply?: BigNumberish;
        };
        withSig?: boolean;
    }): Promise<void>;
    collect(withSig?: boolean): Promise<BigNumber>;
    loadCreatedTokenFiles(creator: string): Promise<Record<string, {
        appId: string;
        modelId: string;
        pkh: string;
        fileContent: {
            file?: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external"> | undefined;
            content?: FileContent | undefined;
        };
    }>>;
    loadCollectedTokenFiles(collector: string): Promise<Record<string, {
        appId: string;
        modelId: string;
        pkh: string;
        fileContent: {
            file?: Omit<import("@meteor-web3/connector").MirrorFile, "content" | "external"> | undefined;
            content?: FileContent | undefined;
        };
    }>>;
}
```

### publish

Used to create a DataToken and generate assetId. Internally, createAssetHandler will be called.

### applyConditionsToFile

Imposes access control conditions on a file that can only be decrypted by the creator and collector. Internally, addGeneralCondition, addSourceCondition and applyFileConditions will be called.

### createTokenFile

Creates a private file first, then concatenates methods publish and applyConditionsToFile, whichs makes the file become a payable file.

### monetizeFile

Similar to createTokenFile, but only for the existing private file instead of creating a new one.

### collect

In order to successfully unlock, you need to call a contract function to meet the access control conditions.
